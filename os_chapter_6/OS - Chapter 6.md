# 🔐 فصل 6: ابزارهای هم‌زمان‌سازی (Synchronization Tools)

در سیستم‌های چندپردازه‌ای، پردازه‌ها و نخ‌ها اغلب نیاز دارند به داده‌های مشترک دسترسی پیدا کنند. اگر این دسترسی به‌درستی مدیریت نشود، منجر به **شرایط رقابتی (Race Conditions)** و رفتارهای پیش‌بینی‌ناپذیر خواهد شد. در این فصل ابزارهایی برای حل این مسئله بررسی می‌شود.

---

## 🧭 فهرست مطالب فصل:

### 1. 🧱 Background (پیش‌زمینه)
- چرا هم‌زمان‌سازی در سیستم‌عامل‌ها ضروری است؟
- بررسی مفاهیم اولیه مثل Race Condition، Thread Interleaving و Atomicity

---

### 2. 🔒 The Critical-Section Problem (مسئله بخش بحرانی)
- هر پردازه دارای بخش بحرانی است که در آن به منابع مشترک دسترسی دارد.
- هدف: طراحی الگوریتمی که **انحصار متقابل (Mutual Exclusion)** را تضمین کند.
- بررسی شرایط لازم:
  - Mutual Exclusion
  - Progress
  - Bounded Waiting

---

### 3. 📏 Peterson’s Solution (راه‌حل پترسون)
- یک راه‌حل نرم‌افزاری کلاسیک برای دو پردازه.
- استفاده از متغیرهای اشتراکی مانند `flag[]` و `turn`

---

### 4. 🧮 Hardware Support for Synchronization (پشتیبانی سخت‌افزاری)
- دستورهای اتمی سطح پایین مانند:
  - TestAndSet
  - Swap
  - CompareAndSwap
- بررسی مزایا و محدودیت‌ها

---

### 5. 🧩 Mutex Locks (قفل‌های متقابل)
- ساده‌ترین ابزار برای کنترل دسترسی متقابل
- شامل توابع `lock()` و `unlock()`
- معرفی مفهوم busy waiting

---

### 6. ⚖️ Semaphores (سمافورها)
- ابزار قدرتمند و عمومی برای هم‌زمان‌سازی
- دو نوع:
  - Counting Semaphore
  - Binary Semaphore (معادل Mutex)
- توابع `wait()` و `signal()`
- خطرات: deadlock و starvation

---

### 7. 👮‍♀️ Monitors (نظارت‌گرها)
- ساختار سطح بالا برای هم‌زمان‌سازی در زبان‌های برنامه‌نویسی
- تسهیل‌کننده‌ی مدیریت منابع اشتراکی بدون مدیریت صریح قفل‌ها توسط برنامه‌نویس

---

### 8. 🧬 Liveness (زنده‌مانی)
- بررسی مشکلاتی مانند:
  - Deadlock (بن‌بست)
  - Starvation (قحطی)
  - Bounded Waiting (محدودیت انتظار)

---

### 9. 📊 Evaluation (ارزیابی نهایی)
- مقایسه ابزارهای مختلف از نظر:
  - سادگی پیاده‌سازی
  - کارایی
  - قابلیت اطمینان
  - تطبیق‌پذیری با سیستم‌های چندپردازه‌ای

---

## ✅ هدف کلی فصل:

> آشنایی با ابزارها و تکنیک‌هایی برای تضمین **اجرای ایمن و قابل پیش‌بینی** برنامه‌ها در محیط‌های هم‌زمان و چندنخی (Multithreaded).

---
# 🎯 اهداف فصل 6: ابزارهای هم‌زمان‌سازی (Synchronization Tools)

این فصل به بررسی ابزارها و تکنیک‌های مهمی می‌پردازد که برای مدیریت هم‌زمانی (Synchronization) در سیستم‌های چندنخی یا چندپردازه‌ای استفاده می‌شوند. اهداف اصلی فصل به شرح زیر است:

---

## 1. 🧩 توصیف مسئله‌ی **Critical Section** و شرایط رقابتی

- تعریف **Critical Section**: بخشی از کد که در آن پردازه به **منابع اشتراکی** (مثل حافظه یا فایل) دسترسی دارد.
- اگر چند پردازه هم‌زمان به این منابع دسترسی پیدا کنند، ممکن است **Race Condition** رخ دهد.
- Race Condition باعث رفتارهای ناسازگار، داده‌های ناقص یا خروجی نادرست می‌شود.

> 🎯 هدف: اطمینان از اینکه در هر لحظه فقط **یک پردازه در بخش بحرانی** قرار دارد.

---

## 2. ⚙️ نمایش راه‌حل‌های سخت‌افزاری

- استفاده از ابزارهای سطح پایین برای کنترل اتمی بودن عملیات:
  - **Memory Barriers** (موانع حافظه)
  - **Compare-and-Swap**
  - **Atomic Variables**
  
> ✅ این ابزارها اغلب توسط زبان‌های سطح بالا یا سیستم‌عامل‌ها برای ساخت ابزارهای هم‌زمان‌سازی استفاده می‌شوند.

---

## 3. 🔒 استفاده از ابزارهای هم‌زمان‌سازی برای حل مسئله:

- **Mutex Locks**: قفل‌های ساده برای ورود و خروج از بخش بحرانی.
- **Semaphores**: ابزار عمومی‌تر که می‌توانند منابع شمارشی را کنترل کنند.
- **Monitors**: ساختاری سطح بالا که به‌صورت خودکار قفل‌ها و شرایط را مدیریت می‌کند.
- **Condition Variables**: مکانیزم‌هایی برای همگام‌سازی با وضعیت مشخص (مثلاً انتظار برای رخداد یک شرط خاص)

> 📌 هر یک از این ابزارها می‌تواند در سناریوهای خاصی مؤثرتر باشد.

---

## 4. 📊 ارزیابی ابزارها در سناریوهای مختلف

- **Low Contention**: تعداد کمی از پردازه‌ها هم‌زمان به منبع دسترسی دارند.
- **Moderate Contention**: رقابت متوسط برای دسترسی به منابع.
- **High Contention**: رقابت شدید میان پردازه‌ها، مانند سرورهای چندنخی با بار سنگین.

> 🎯 انتخاب ابزار مناسب با توجه به میزان رقابت بین پردازه‌ها بسیار حیاتی است.

---

## 🧾 نتیجه‌گیری:

این فصل به شما کمک می‌کند تا:

- درک عمیقی از **مشکلات هم‌زمانی** پیدا کنید،
- ابزارهای **سیستم‌عاملی و سخت‌افزاری** لازم برای مدیریت آن را بیاموزید،
- و در نهایت، راه‌حل‌هایی **مناسب با شرایط رقابتی متفاوت** را تحلیل و انتخاب کنید.
---
# 🔍 پیش‌زمینه (Background)

در سیستم‌عامل‌هایی که از چندنخی یا چندپردازه‌ای پشتیبانی می‌کنند، امکان اجرای هم‌زمان (Concurrency) برای چندین پردازه یا نخ وجود دارد. این ویژگی مزایایی دارد اما چالش‌هایی نیز به همراه می‌آورد.

---

## ⚙️ اجرای هم‌زمان پردازه‌ها

- پردازه‌ها می‌توانند **به‌صورت هم‌زمان اجرا شوند**.
- سیستم‌عامل ممکن است **هر لحظه یکی از آن‌ها را متوقف** کند (interrupt)، حتی زمانی که اجرای آن هنوز کامل نشده است.
- بنابراین، ممکن است عملیات ناتمام روی منابع اشتراکی بماند.

---

## ⚠️ مشکل دسترسی هم‌زمان به داده‌های مشترک

- زمانی که چند پردازه به **داده‌ای مشترک** (مثل متغیر، بافر، فایل) دسترسی هم‌زمان دارند، ممکن است داده‌ها دچار **ناهم‌خوانی (Inconsistency)** شوند.
- این مشکل زمانی رخ می‌دهد که عملیات خواندن/نوشتن توسط پردازه‌ها به‌صورت **بینابینی (Interleaved)** انجام شود.

---

## 🛡️ نیاز به هماهنگی

برای حفظ **سازگاری داده‌ها (Data Consistency)**، سیستم باید مکانیزم‌هایی فراهم کند که:

- **ترتیب اجرای پردازه‌های وابسته به یکدیگر** حفظ شود.
- پردازه‌ها در هنگام دسترسی به منابع اشتراکی، تداخل ایجاد نکنند.

---

## 🧪 مثال: مسئله بافر محدود (Bounded Buffer Problem)

- در فصل 4 این مشکل را دیدیم:
  - **تولیدکننده (Producer)** و **مصرف‌کننده (Consumer)** به‌صورت هم‌زمان به یک **شمارنده مشترک (counter)** دسترسی داشتند.
  - هر دو پردازه این شمارنده را به‌روزرسانی می‌کردند.
  - چون این عملیات **اتمی (Atomic)** نبود، گاهی به‌جای افزایش یا کاهش درست، مقدار آن **ناهم‌خوان (Race Condition)** می‌شد.

> 🎯 نتیجه: دسترسی هم‌زمان بدون هماهنگی → رفتار نادرست و غیرقابل پیش‌بینی

---

## 📌 جمع‌بندی

> در سیستم‌های چندنخی یا چندپردازه‌ای، بدون کنترل مناسب، دسترسی هم‌زمان به داده‌های مشترک می‌تواند منجر به **شرایط رقابتی** شود.  
> بنابراین، نیاز به ابزارهایی برای **هم‌زمان‌سازی و ترتیب‌دهی اجرای پردازه‌ها** داریم.

---
# ⚠️ Race Condition در Producer/Consumer

## 👷 کد تولیدکننده (Producer)

```c
while (true) {
    /* produce an item in next_produced */
    while (counter == BUFFER_SIZE) ;  // بافر پر است؛ صبر کن
    buffer[in] = next_produced;
    in = (in + 1) % BUFFER_SIZE;
    counter++;  // 🔴 افزایش شمارنده
}
````

---

## 🧍‍♂️ کد مصرف‌کننده (Consumer)

```c
while (true) {
    while (counter == 0) ;  // بافر خالی است؛ صبر کن
    next_consumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
    counter--;  // 🔴 کاهش شمارنده
    /* consume the item in next_consumed */
}
```

---

## 🧬 مسئله اصلی: به‌روزرسانی هم‌زمان متغیر `counter`

- متغیر `counter` توسط هر دو پردازه (تولیدکننده و مصرف‌کننده) به‌صورت هم‌زمان و بدون هماهنگی تغییر می‌کند.
    
- عملیات `counter++` و `counter--` در ظاهر یک خط هستند، اما در واقع به چند **مرحله‌ داخلی** در سطح سخت‌افزار شکسته می‌شوند.
    

---

## ⚙️ نحوه عملکرد داخلی عملیات‌ها:

### 🔼 افزایش (`counter++`)

```asm
register1 = counter
register1 = register1 + 1
counter = register1
```

### 🔽 کاهش (`counter--`)

```asm
register2 = counter
register2 = register2 - 1
counter = register2
```

---

## 🧪 مثال از تداخل اجرای تولیدکننده و مصرف‌کننده:

فرض کنیم مقدار اولیه `counter = 5` است و پردازه‌ها به‌صورت زیر اجرا شوند:

|گام|عملیات|توضیح|
|---|---|---|
|S0|Producer → `register1 = counter`|register1 = 5|
|S1|Producer → `register1 = register1 + 1`|register1 = 6|
|S2|Consumer → `register2 = counter`|register2 = 5|
|S3|Consumer → `register2 = register2 - 1`|register2 = 4|
|S4|Producer → `counter = register1`|counter = 6 (در ظاهر درست است)|
|S5|Consumer → `counter = register2`|❌ counter = 4 (اشتباه!)|

---

## ❗ نتیجه: بروز شرایط رقابتی (Race Condition)

> هر دو پردازه فکر می‌کنند عملیات خود را درست انجام داده‌اند، اما مقدار نهایی `counter` نادرست است و منجر به اختلال در منطق برنامه می‌شود.

---

## ✅ راه‌حل چیست؟

برای جلوگیری از چنین وضعیتی باید:

- بخش‌هایی از کد که به داده‌های مشترک دسترسی دارند، در **بخش بحرانی (Critical Section)** قرار گیرند.
    
- از ابزارهایی مانند:
    
    - Mutex Lock
        
    - Semaphore
        
    - Monitor  
        استفاده شود تا در هر لحظه فقط **یک پردازه** به آن بخش دسترسی داشته باشد.
        
---

# ⚠️ Race Condition در فراخوانی fork()

در این مثال، شرایط رقابتی (Race Condition) در زمان ساخت فرآیندهای فرزند توسط چند پردازه هم‌زمان بررسی می‌شود.

---

## 🔧 وضعیت مسئله

- دو پردازه به نام‌های `P₀` و `P₁` به‌طور هم‌زمان از تابع سیستمی `fork()` برای ایجاد فرزند استفاده می‌کنند.
- هسته سیستم‌عامل (Kernel) از متغیر **`next_available_pid`** برای تخصیص شناسه پردازه (PID) جدید استفاده می‌کند.
- این متغیر **اشتراکی** است و اگر هم‌زمان توسط چند پردازه استفاده شود، منجر به تخصیص **PID تکراری** می‌شود.

---

## 🧪 ترتیب وقوع مشکل

### فرض: مقدار اولیه `next_available_pid = 2615`

| زمان | پردازه `P₀`                     | پردازه `P₁`                     |
|------|----------------------------------|----------------------------------|
| t₀   | درخواست PID می‌دهد               |                                  |
| t₁   | `next_available_pid = 2615`      |                                  |
| t₂   |                                  | درخواست PID می‌دهد               |
| t₃   |                                  | `next_available_pid = 2615`      |
| t₄   | PID = 2615 به `P₀` داده می‌شود   | PID = 2615 به `P₁` داده می‌شود   |

🎯 در نتیجه، **هر دو پردازه، یک PID یکسان (2615)** به فرزندان خود اختصاص می‌دهند، که **غیرمجاز و خطرناک** است.

---

## ❌ پیامد

> اگر مکانیزمی برای جلوگیری از دسترسی هم‌زمان `P₀` و `P₁` به `next_available_pid` وجود نداشته باشد، ممکن است دو پردازه مختلف PID یکسان دریافت کنند.

---

## ✅ راه‌حل

برای جلوگیری از این شرایط رقابتی، باید:

- از ابزارهای **هم‌زمان‌سازی در سطح هسته (Kernel Synchronization)** مانند:
  - قفل‌های چرخشی (Spinlocks)
  - Semaphores در کرنل
  - عملیات اتمی (Atomic Instructions)
  استفاده شود.

---

## 📊 نمودار ترتیب زمان اجرای عملیات (Mermaid)

![[Pasted image 20250513170822.png]]

---

## 🧾 جمع‌بندی

> برای هر منبع مشترک در سیستم‌عامل (مثل `next_available_pid`) باید دسترسی هم‌زمان کنترل شود، در غیر این صورت ممکن است وضعیت بحرانی و ناپایدار به‌وجود آید.

---

# 🔒 مسئله بخش بحرانی (Critical Section Problem)

---

## 🧩 تعریف مسئله

در یک سیستم با چند پردازه هم‌زمان:

```

P₀, P₁, P₂, ..., Pₙ₋₁

```

هر پردازه ممکن است دارای بخشی از کد باشد که در آن با منابع **مشترک** کار می‌کند:

- تغییر مقدار متغیرهای مشترک
- نوشتن در فایل‌ها
- به‌روزرسانی جداول حافظه یا اشتراکی

این بخش‌ها را **بخش بحرانی (Critical Section)** می‌نامیم.

---

## 🚨 قانون اصلی بخش بحرانی

> در هر لحظه **فقط یک پردازه** مجاز به ورود به بخش بحرانی است.

یعنی اگر پردازه‌ای داخل بخش بحرانی است، پردازه‌های دیگر باید صبر کنند تا از آن خارج شود.

---

## 🧠 هدف مسئله

هدف اصلی این مسئله طراحی **پروتکلی** است که سه شرط را فراهم کند:

1. ✅ **Mutual Exclusion (排‌مانع بودن)**: فقط یک پردازه در هر زمان می‌تواند وارد بخش بحرانی شود.
2. 🔁 **Progress (پیشرفت)**: اگر هیچ پردازه‌ای در بخش بحرانی نیست، باید امکان ورود برای یکی از پردازه‌های منتظر وجود داشته باشد.
3. ♻️ **Bounded Waiting (انتظار محدود)**: هر پردازه‌ای که درخواست ورود به بخش بحرانی دارد، باید در زمان محدودی بتواند وارد شود (گره نخورد!).

---

## 🧱 ساختار کلی اجرای پردازه

کد هر پردازه به چهار بخش تقسیم می‌شود:

```

while (true) {  
Entry Section // درخواست ورود به بخش بحرانی  
Critical Section // بخش بحرانی: دسترسی به منابع مشترک  
Exit Section // خروج و آزادسازی منابع  
Remainder Section // بقیه کد پردازه  
}

```

---

## 📌 جمع‌بندی

> مسئله بخش بحرانی یکی از مهم‌ترین مفاهیم در طراحی سیستم‌های عامل و برنامه‌های چندنخی است.  
> راه‌حل‌های متنوعی برای حل این مسئله ارائه شده‌اند که شامل **راه‌حل‌های نرم‌افزاری، سخت‌افزاری، و ابزارهای هم‌زمان‌سازی** مثل Mutex، Semaphore، و Monitor می‌شود.

---
# 🔐 Critical Section – ساختار و شرایط حل مسئله

---

## 🧱 ساختار عمومی یک پردازه Pi

هر پردازه‌ای که در سیستم هم‌زمان اجرا می‌شود، معمولا به صورت یک حلقه بی‌نهایت است که شامل چهار بخش اصلی است:

```cpp
while (true) {
    entry section       // ورود و بررسی شرایط بخش بحرانی
    critical section    // کد مربوط به منابع مشترک
    exit section        // خروج و آزادسازی منابع
    remainder section   // بقیه برنامه
}
````

---

## 🎯 هدف مسئله بخش بحرانی

هدف، طراحی یک **پروتکل هماهنگ‌کننده** است که به پردازه‌ها اجازه دهد به شکلی امن وارد بخش بحرانی شوند، بدون تداخل با پردازه‌های دیگر.

---

## ✅ شرایط لازم برای یک راه‌حل درست

### 1. **Mutual Exclusion (排‌مانع بودن)**

اگر پردازه `Pᵢ` در حال اجرا در بخش بحرانی باشد، هیچ پردازه‌ای نباید در همان زمان وارد بخش بحرانی شود.

---

### 2. **Progress (پیشرفت)**

اگر هیچ پردازه‌ای داخل بخش بحرانی نباشد و برخی پردازه‌ها مایل به ورود باشند، انتخاب یکی از آن‌ها برای ورود نباید به تأخیر بی‌نهایت بیفتد.

---

### 3. **Bounded Waiting (انتظار محدود)**

زمانی که پردازه‌ای درخواست ورود به بخش بحرانی را می‌دهد، باید **حداکثر تعداد مشخصی** از پردازه‌ها قبل از آن وارد بخش بحرانی شوند. یعنی نباید پردازه‌ای برای همیشه پشت صف بماند.

---

## ⚙️ فرضیات پایه

- هر پردازه در مدت زمان غیر صفر اجرا می‌شود (یعنی متوقف یا قفل نشده نیست).
    
- هیچ فرضی درباره سرعت نسبی پردازه‌ها یا ترتیب اجرای آن‌ها نداریم (کاملا نابرابر ممکن است باشند).
    

---

## 🧾 جمع‌بندی

> هر پروتکلی برای حل مسئله بخش بحرانی باید این سه شرط مهم را **همزمان** برقرار کند. در غیر این صورت، یا ممکن است تداخل داده ایجاد شود، یا برخی پردازه‌ها هرگز وارد بخش بحرانی نشوند (Starvation).

---
# 🧠 راه‌حل نرم‌افزاری اول (Software Solution 1)

---

## 🔢 شرایط مسئله

- این راه‌حل فقط برای **دو پردازه** (P₀ و P₁) قابل استفاده است.
- فرض می‌شود که **دستورات load و store اتمی هستند**؛ یعنی در میانه اجرا قابل قطع‌شدن نیستند.

---

## 🧮 متغیر مشترک بین پردازه‌ها

پردازه‌ها فقط یک متغیر مشترک دارند:

```c
int turn;
````

- مقدار این متغیر مشخص می‌کند که **نوبت کدام پردازه** است که وارد بخش بحرانی شود.
    
- مقدار اولیه متغیر به `i` تنظیم می‌شود، که نشان می‌دهد پردازه `Pᵢ` حق ورود دارد.
    

---

## 📜 الگوریتم برای پردازه Pi

```c
while (true) {
    while (turn == j);        // در صورتی که نوبت پردازه j باشد، منتظر بمان
    // بخش بحرانی
    turn = j;                 // نوبت را به پردازه j بده
    // بخش باقی‌مانده
}
```

---

## ✅ بررسی صحت الگوریتم

### 1. **Mutual Exclusion**

- در هر لحظه فقط یکی از پردازه‌ها می‌تواند وارد بخش بحرانی شود، چرا که مقدار متغیر `turn` فقط می‌تواند یکی از دو مقدار `0` یا `1` را داشته باشد.
    
- اگر `Pᵢ` داخل بخش بحرانی است، یعنی `turn == i`، پس `Pⱼ` باید منتظر بماند چون `turn != j`.
    

---

### 2. ❓ **Progress** (پیشرفت)

- در این راه‌حل، امکان دارد یک پردازه به صورت متوالی وارد بخش بحرانی شود و پردازه دیگر منتظر بماند تا نوبتش برسد.
    
- اما هیچ شرطی برای **اولویت یا انتخاب هوشمندانه پردازه‌ها** وجود ندارد، بنابراین ممکن است به طور ناخواسته پیشرفت دچار اشکال شود.
    

---

### 3. ❌ **Bounded Waiting** (انتظار محدود)

- هیچ مکانیزمی وجود ندارد که تضمین کند پردازه‌ای که درخواست ورود داده، بعد از حداکثر چند بار اجرا شدن پردازه مقابل وارد بخش بحرانی شود.
    
- بنابراین امکان **Starvation** (گرسنگی پردازه) وجود دارد.
    

---

## 🧾 جمع‌بندی

|ویژگی|وضعیت|
|---|---|
|Mutual Exclusion|✅ برقرار است|
|Progress|⚠️ ممکن است نقض شود|
|Bounded Waiting|❌ برقرار نیست|

این الگوریتم ساده و شهودی است، اما برای سیستم‌های واقعی کافی نیست.

---
# 🚩 Flag-Based Algorithm – راه‌حل ساده برای دو پردازه

---

## ⚙️ ساختار الگوریتم

این الگوریتم نیز برای **دو پردازه** (P₀ و P₁) طراحی شده است.

ایده اصلی این است که هر پردازه با استفاده از یک **پرچم منطقی (Boolean Flag)** اعلام می‌کند که قصد ورود به بخش بحرانی را دارد.

---

## 🧮 متغیرهای مشترک

```c
bool flag[2];  // برای هر پردازه یک پرچم (false به معنی اینکه قصد ورود ندارد)
````

---

## 📜 کد الگوریتم برای پردازه Pi

```c
while (true) {
    flag[i] = true;            // اعلام تمایل به ورود به بخش بحرانی
    while (flag[j]) ;          // اگر پردازه دیگر نیز قصد ورود داشته باشد، منتظر بمان
    // --- بخش بحرانی ---
    flag[i] = false;           // خروج از بخش بحرانی
    // --- بخش باقی‌مانده ---
}
```

---

## ✅ بررسی ویژگی‌های الگوریتم

### 1. **Mutual Exclusion (排‌مانع بودن)** ✅

- اگر هر دو پردازه بخواهند هم‌زمان وارد بخش بحرانی شوند، فقط یکی از آن‌ها می‌تواند وارد شود. چون پردازه دوم شرط `while (flag[j])` را بررسی می‌کند و منتظر می‌ماند.
    

---

### 2. **Progress (پیشرفت)** ❌

- در صورتی که هر دو پردازه هم‌زمان مقدار پرچم خود را `true` کنند، هر دو وارد حلقه `while (flag[j])` می‌شوند و **در حالت انتظار بی‌پایان (Deadlock) می‌مانند**. پس الگوریتم شرط پیشرفت را نقض می‌کند.
    

---

### 3. **Bounded Waiting (انتظار محدود)** ❌

- ممکن است پردازه‌ای بارها تلاش کند وارد شود، اما به دلیل عدم کنترل نوبت یا اولویت، همیشه منتظر بماند. پس انتظار محدود هم برقرار نیست.
    

---

## 🧾 جمع‌بندی

|ویژگی|وضعیت|
|---|---|
|Mutual Exclusion|✅ برقرار است|
|Progress|❌ امکان بن‌بست وجود دارد|
|Bounded Waiting|❌ امکان گرسنگی وجود دارد|

---

## 📌 نکته مهم

> این الگوریتم ساده، شروع خوبی برای درک همزمانی (Concurrency) و کنترل دسترسی به منابع مشترک است، اما در عمل قابل اطمینان نیست. راه‌حل‌هایی مانند **Peterson’s Algorithm** یا **Mutex** و **Semaphore**‌ها، نسخه‌های بهبود یافته آن هستند.

---
# 🔐 راه‌حل پترسون (Peterson’s Solution)


## 📌 ویژگی‌ها

Peterson’s Solution یک الگوریتم کلاسیک برای حل مسئله‌ی بخش بحرانی در **سیستم‌های دارای دو پردازه (Process)** است.

این راه‌حل:
- تنها به **دو متغیر اشتراکی** نیاز دارد.
- فرض می‌کند که دستورات `load` و `store` در سطح سخت‌افزار **اتمی** هستند (یعنی نمی‌توانند توسط پردازه‌ای دیگر قطع شوند).

---

## 🧮 متغیرهای مشترک

```c
int turn;            // نوبت ورود به بخش بحرانی
bool flag[2];        // flag[i] = true یعنی Pi قصد ورود به بخش بحرانی را دارد
````

---

## 👨‍💻 الگوریتم برای پردازه Pi

```c
while (true) {
    flag[i] = true;      // پردازه i تمایل خود را اعلام می‌کند
    turn = j;            // نوبت را به پردازه مقابل می‌دهد

    while (flag[j] && turn == j)
        ;                // اگر پردازه j نیز تمایل دارد و نوبت اوست، منتظر بمان

    // --- بخش بحرانی ---

    flag[i] = false;     // پردازه i از بخش بحرانی خارج می‌شود

    // --- بخش باقی‌مانده ---
}
```

---

## ✅ تحلیل ویژگی‌ها

### 1. Mutual Exclusion (排‌مانع بودن)

- اگر هر دو پردازه بخواهند هم‌زمان وارد شوند، تنها **یکی** موفق می‌شود. چون شرط `turn == j` باعث می‌شود یکی منتظر بماند.
    

---

### 2. Progress (پیشرفت)

- اگر تنها یک پردازه قصد ورود داشته باشد، منتظر نخواهد ماند و سریع وارد می‌شود.
    

---

### 3. Bounded Waiting (انتظار محدود)

- نوبت‌ها بین پردازه‌ها **عادلانه تقسیم** می‌شود، و هر پردازه در نهایت می‌تواند وارد شود.
    

---

## ✅ نتیجه‌گیری

|ویژگی|وضعیت|
|---|---|
|Mutual Exclusion|✅ برقرار است|
|Progress|✅ برقرار است|
|Bounded Waiting|✅ برقرار است|

---

## 💡 یادآوری

> الگوریتم پترسون یکی از معدود راه‌حل‌های نرم‌افزاری است که می‌تواند بدون کمک سخت‌افزار، مسئله‌ی بخش بحرانی را برای دو پردازه حل کند. با این حال، در سیستم‌های مدرن با پردازنده‌های چند هسته‌ای، از روش‌های سخت‌افزاری و قفل‌های پیشرفته‌تر (مانند Mutex و Semaphore) استفاده می‌شود.

---
# 🖥️ سخت‌افزار همگام‌سازی (Synchronization Hardware)


## 🎯 هدف

بسیاری از سیستم‌ها از **پشتیبانی سخت‌افزاری** برای پیاده‌سازی کد **critical section** استفاده می‌کنند تا مطمئن شوند که تنها یک پردازه در هر زمان می‌تواند به بخش بحرانی دسترسی پیدا کند.

---

## 🖱️ سیستم‌های تک‌پردازه (Uniprocessors)

- در سیستم‌های **تک‌پردازه (Uniprocessor)**، برای جلوگیری از **پیش‌مقاطعه (Preemption)** می‌توان **قطعی کردن (Interrupts)** را غیرفعال کرد.
  - در این حالت، کد در حال اجرا تا اتمام اجرا بدون مداخله ادامه پیدا می‌کند.
  
- **محدودیت‌ها**:
  - این روش به دلیل **عدم مقیاس‌پذیری** (Scalability) مناسب برای سیستم‌های چندپردازه‌ای (Multiprocessor) نیست.
  - سیستم‌های عامل که از این روش استفاده می‌کنند، معمولاً به خوبی مقیاس‌پذیر نیستند.

---

## 🔧 انواع پشتیبانی سخت‌افزاری

### 1. **دستورات سخت‌افزاری (Hardware Instructions)**

- برخی از سیستم‌ها دستورات خاصی دارند که برای پیاده‌سازی عملیات همگام‌سازی طراحی شده‌اند. این دستورات می‌توانند عملیات‌هایی مانند **تست و تنظیم** (Test and Set) یا **سوئیچ کردن و بستن** (Swap) را انجام دهند تا دسترسی به بخش‌های بحرانی را کنترل کنند.

### 2. **متغیرهای اتمیک (Atomic Variables)**

- **متغیرهای اتمیک** به طور خاص برای جلوگیری از شرایط رقابتی طراحی شده‌اند. این متغیرها فقط توسط یک پردازه در یک زمان قابل تغییر هستند و تضمین می‌کنند که تغییرات بر روی آن‌ها از خارج قابل تغییر نباشد.

---

## 📋 نتیجه‌گیری

- استفاده از **پشتیبانی سخت‌افزاری** همگام‌سازی می‌تواند از بروز **مشکلات رقابتی** در دسترسی به منابع مشترک جلوگیری کند.
- در سیستم‌های چندپردازه‌ای، روش‌هایی مانند **دستورات سخت‌افزاری** و **متغیرهای اتمیک** می‌توانند از **موانع بهینه‌سازی** جلوگیری کنند.
---
# 🔒 قفل‌های متقارن (Mutex Locks)


## 🎯 هدف

راه‌حل‌های قبلی برای حل مسئله **critical section** پیچیده و معمولاً غیرقابل دسترس برای برنامه‌نویسان اپلیکیشن هستند.  
برای این منظور، طراحان سیستم‌عامل ابزارهایی نرم‌افزاری برای حل این مشکل ایجاد کرده‌اند.

---

## 🧰 ساده‌ترین ابزار: قفل متقارن (Mutex Lock)

- **قفل متقارن (Mutex Lock)**، ساده‌ترین راه‌حل است که توسط طراحان سیستم‌عامل پیاده‌سازی می‌شود.
- یک متغیر بولی (Boolean variable) نشان می‌دهد که آیا قفل در دسترس است یا خیر.

### ✅ نحوه عملکرد قفل متقارن

1. **دریافت قفل (acquire())**: 
   - پردازه ابتدا قفل را **دریافت** می‌کند.
   
2. **آزاد کردن قفل (release())**: 
   - پس از اتمام کار در بخش بحرانی، قفل باید **آزاد** شود.
   
### 🔒 ویژگی‌ها:

- **دریافت و آزاد کردن قفل باید به صورت اتمیک** انجام شود.
- معمولاً این عملیات با استفاده از دستورهای سخت‌افزاری اتمیک مانند **مقایسه و جایگزینی (compare-and-swap)** پیاده‌سازی می‌شود.

---

## ⚠️ مشکل اصلی: **منتظر بودن مشغول (Busy Waiting)**

- این راه‌حل **منتظر بودن مشغول (Busy Waiting)** ایجاد می‌کند.
- زمانی که پردازه‌ای نتواند قفل را بدست آورد، باید منتظر بماند و در حال منتظر بودن، **CPU را مصرف می‌کند**.

---

## 🔄 قفل اسپین (Spinlock)

- به دلیل استفاده از **منتظر بودن مشغول**، این قفل به **قفل اسپین (Spinlock)** معروف است.
- در این قفل، پردازه به طور مداوم بررسی می‌کند که آیا قفل آزاد شده است یا نه.

---

## 📋 نتیجه‌گیری

- **قفل‌های متقارن** روش ساده‌ای برای جلوگیری از دسترسی همزمان به بخش بحرانی هستند.
- با این حال، این روش نیازمند **منتظر بودن مشغول** است که ممکن است **کارایی سیستم** را تحت تأثیر قرار دهد.

---
# 🛠️ راه‌حل مسئله بخش بحرانی با استفاده از قفل‌های متقارن (Mutex Locks)


## 🎯 هدف

استفاده از **قفل‌های متقارن** برای جلوگیری از دسترسی همزمان به بخش بحرانی و اطمینان از اینکه تنها یک پردازه در هر زمان می‌تواند به آن دسترسی پیدا کند.

---

## 🔒 الگوریتم

برای حل مشکل **بخش بحرانی (Critical Section)** با استفاده از قفل متقارن، یک پردازه به صورت مداوم در یک حلقه به دنبال قفل می‌گردد و زمانی که قفل در دسترس باشد، وارد بخش بحرانی می‌شود.

### ✅ کد مثال:

```c
while (true) {
    acquire(lock);        // درخواست قفل
    critical_section();    // اجرای بخش بحرانی
    release(lock);        // آزادسازی قفل
    remainder_section();   // اجرای بخش باقی‌مانده
}
````

### ✅ توضیحات:

- **acquire(lock)**: پردازه درخواست قفل می‌کند. اگر قفل آزاد باشد، آن را بدست می‌آورد، در غیر این صورت منتظر می‌ماند.
    
- **critical_section()**: پردازه وارد بخش بحرانی می‌شود و عملیات مربوطه را انجام می‌دهد.
    
- **release(lock)**: پس از اتمام کار در بخش بحرانی، قفل آزاد می‌شود تا دیگر پردازه‌ها بتوانند از آن استفاده کنند.
    
- **remainder_section()**: پردازه به انجام سایر عملیات‌های غیر بحرانی می‌پردازد.
    

---

## ⚠️ نکات مهم:

- **منتظر بودن مشغول (Busy Waiting)**: این الگوریتم از منتظر بودن مشغول برای بررسی در دسترس بودن قفل استفاده می‌کند.
    
- این ممکن است باعث **اتلاف منابع سیستم** به ویژه در شرایطی با تعداد پردازه‌های زیاد شود.
    

---

## 📋 نتیجه‌گیری

استفاده از **قفل‌های متقارن (Mutex Locks)** یکی از ساده‌ترین روش‌ها برای حل مشکل دسترسی همزمان به بخش بحرانی است، اما باید مراقب **اتلاف منابع** ناشی از منتظر بودن مشغول باشیم.

---
# 💻 راه‌حل مبتنی بر وقفه‌ها (Interrupt-based Solution)

## 🎯 هدف

در این روش، برای حل مسئله **دسترسی همزمان به بخش بحرانی**، از وقفه‌ها استفاده می‌شود.

---

## 🔑 بخش‌های اصلی:

- **بخش ورودی (Entry Section)**: وقفه‌ها غیرفعال می‌شوند تا پردازه در هنگام دسترسی به بخش بحرانی مورد پیش‌مقاطعه قرار نگیرد.
- **بخش خروجی (Exit Section)**: پس از اتمام کار در بخش بحرانی، وقفه‌ها دوباره فعال می‌شوند.

---

## ⚠️ آیا این راه‌حل مشکل را حل می‌کند؟

1. **اگر بخش بحرانی مدت زمان زیادی (مثل یک ساعت) طول بکشد، آیا این راه‌حل کارآمد خواهد بود؟**
   - اگر کد بخش بحرانی زمان زیادی طول بکشد، استفاده از این روش منجر به **اتلاف طولانی مدت منابع** می‌شود و پردازه‌های دیگر نمی‌توانند وارد بخش بحرانی شوند.

2. **آیا ممکن است برخی پردازه‌ها هیچ‌گاه وارد بخش بحرانی خود نشوند؟**
   - بله، اگر پردازه‌ای نتواند به موقع وارد بخش بحرانی شود، ممکن است به دلیل غیرفعال بودن وقفه‌ها، **به طور دائم منتظر بماند**.

3. **اگر سیستم دارای دو پردازنده باشد، آیا این راه‌حل کار می‌کند؟**
   - در سیستم‌های چندپردازه‌ای (Multiprocessor)، غیرفعال کردن وقفه‌ها به طور کامل روی هر پردازنده **مؤثر نخواهد بود**. این راه‌حل برای سیستم‌های تک‌پردازه‌ای مناسب است، اما برای سیستم‌های چندپردازه‌ای نمی‌تواند اطمینان دهد که تنها یک پردازه وارد بخش بحرانی شود.

---

# 🛠️ دستورات سخت‌افزاری (Hardware Instructions)

برای حل مسئله **دسترسی همزمان** و جلوگیری از مشکلاتی مانند **منتظر بودن مشغول** یا **اتلاف منابع**، از دستورات سخت‌افزاری استفاده می‌شود که به صورت اتمیک و بدون وقفه عمل می‌کنند.

### ✅ دستورات اصلی:

1. **Test-and-Set**:
   - این دستور یک کلمه حافظه را تست و تغییر می‌دهد به صورت اتمیک.
   
2. **Compare-and-Swap**:
   - این دستور به صورت اتمیک دو کلمه را مقایسه کرده و در صورت تطابق، محتوای آن‌ها را جابجا می‌کند.

این دستورات به سیستم کمک می‌کنند تا عملیات‌های دسترسی به بخش بحرانی به صورت **اتمی** انجام شوند، بدون اینکه نیازی به منتظر بودن مشغول باشد.

---

## 📋 نتیجه‌گیری

- استفاده از **غیرفعال کردن وقفه‌ها** برای جلوگیری از پیش‌مقاطعه، ممکن است در سیستم‌های تک‌پردازه‌ای مفید باشد، اما در سیستم‌های چندپردازه‌ای مشکلاتی به وجود می‌آید.
- برای حل این مشکلات، دستورات **Test-and-Set** و **Compare-and-Swap** برای اطمینان از **دسترس‌پذیری به بخش بحرانی به صورت اتمیک** استفاده می‌شوند.


---

# 🔐 دستور **test_and_set**


## 🎯 تعریف دستور **test_and_set**

دستور **test_and_set** یک دستور اتمیک است که یک متغیر بولی را بررسی کرده و مقدار جدید آن را به `true` تغییر می‌دهد. این دستور همزمان، بدون وقفه و به‌طور اتمیک اجرا می‌شود.

### ✅ تعریف:

```c
boolean test_and_set (boolean *target) {
    boolean rv = *target;
    *target = true;
    return rv;
}
````

- **rv**: مقدار اصلی متغیر ورودی `*target` را ذخیره می‌کند.
    
- مقدار `*target` به `true` تغییر می‌یابد.
    
- در نهایت، مقدار اولیه `*target` (قبل از تغییر) بازگشت داده می‌شود.
    

---

## ⚙️ ویژگی‌ها و خصوصیات دستور **test_and_set**

- **اجرا به‌صورت اتمیک**: یعنی این دستور به طور کامل اجرا می‌شود و هیچ پردازه دیگری نمی‌تواند در حین اجرای آن وارد عمل شود.
    
- **مقدار بازگشتی**: مقدار اصلی متغیر ورودی قبل از تغییر به `true` بازگشت داده می‌شود.
    
- **تغییر مقدار**: پس از اجرای دستور، مقدار متغیر به `true` تغییر می‌کند.
    

---

# 💡 راه‌حل با استفاده از **test_and_set()**

در این روش، از یک متغیر بولی به نام `lock` استفاده می‌شود که به طور مشترک در میان پردازه‌ها قرار می‌گیرد. این متغیر ابتدا به مقدار `false` تنظیم می‌شود.

### ✅ راه‌حل:

```c
do {
    while (test_and_set(&lock))
        ; /* do nothing */
    /* critical section */
    lock = false;
    /* remainder section */
} while (true);
```

1. پردازه ابتدا به‌طور مداوم از **test_and_set** برای بررسی قفل استفاده می‌کند.
    
2. اگر قفل در دسترس نباشد (`test_and_set(&lock)` مقدار `true` باز می‌گرداند)، پردازه در حالت **منتظر بودن مشغول (busy waiting)** می‌ماند.
    
3. هنگامی که قفل آزاد می‌شود، پردازه وارد بخش بحرانی شده و پس از اتمام کار، قفل را آزاد می‌کند.
    

---

## ⚠️ آیا این راه‌حل مسئله بخش بحرانی را حل می‌کند؟

### ❓ مشکلات این راه‌حل:

1. **منتظر بودن مشغول (Busy Waiting)**:
    
    - پردازه‌ها باید برای دریافت قفل در حالت **منتظر بودن مشغول** بمانند که باعث **اتلاف منابع** می‌شود. این روش ممکن است کارایی سیستم را پایین آورد.
        
2. **Starvation**:
    
    - اگر تعدادی پردازه همواره در تلاش برای دریافت قفل باشند، ممکن است برخی از آن‌ها هیچ‌گاه نتوانند وارد بخش بحرانی شوند و به اصطلاح دچار **گرسنگی (Starvation)** شوند.
        
3. **مقیاس‌پذیری در سیستم‌های چندپردازه‌ای (Multiprocessor)**:
    
    - در سیستم‌های چندپردازه‌ای، این روش ممکن است مشکلاتی ایجاد کند، زیرا **در هر پردازنده** عملیات `test_and_set` به صورت اتمیک انجام می‌شود، اما از آنجا که همه پردازه‌ها ممکن است بر روی منابع مشترک دسترسی داشته باشند، ممکن است برخی از پردازه‌ها به صورت دائمی منتظر بمانند.
        

---

## 📋 نتیجه‌گیری

دستور **test_and_set** یکی از روش‌های رایج برای پیاده‌سازی **قفل‌ها** در بخش‌های بحرانی است. این روش از ویژگی‌های اتمیک بودن بهره می‌برد، اما به دلیل **منتظر بودن مشغول** و **گرسنگی پردازه‌ها** ممکن است کارایی سیستم را تحت تأثیر قرار دهد.

---

# 🔄 دستور **compare_and_swap**


## 🎯 تعریف دستور **compare_and_swap**

دستور **compare_and_swap** یک دستور اتمیک است که به شما اجازه می‌دهد یک مقدار را با یک شرط خاص تغییر دهید. این دستور مقدار ورودی را مقایسه کرده و در صورتی که مقدار متغیر برابر با مقدار مورد انتظار باشد، آن را با مقدار جدید جایگزین می‌کند.

### ✅ تعریف:

```c
int compare_and_swap(int *value, int expected, int new_value) {
    int temp = *value;
    if (*value == expected)
        *value = new_value;
    return temp;
}
````

- **value**: آدرس متغیری که باید تغییر کند.
    
- **expected**: مقداری که می‌خواهیم با آن مقایسه کنیم.
    
- **new_value**: مقداری که باید به متغیر `value` تخصیص داده شود در صورتی که مقدار فعلی برابر با `expected` باشد.
    

---

## ⚙️ ویژگی‌ها و خصوصیات دستور **compare_and_swap**

- **اجرا به‌صورت اتمیک**: این دستور به طور کامل و بدون وقفه اجرا می‌شود.
    
- **مقدار بازگشتی**: مقدار اصلی متغیر ورودی **value** قبل از تغییر به `new_value` بازگشت داده می‌شود.
    
- **شرط تغییر**: تغییر مقدار متغیر تنها زمانی انجام می‌شود که مقدار فعلی **value** برابر با **expected** باشد.
    

---

# 💡 راه‌حل با استفاده از **compare_and_swap**

در این روش، از یک متغیر **lock** به عنوان قفل استفاده می‌شود. این متغیر ابتدا به مقدار ۰ (قفل آزاد) تنظیم می‌شود.

### ✅ راه‌حل:

```c
while (true) {
    while (compare_and_swap(&lock, 0, 1) != 0)
        ; /* do nothing */
    /* critical section */
    lock = 0;
    /* remainder section */
}
```

1. **`compare_and_swap(&lock, 0, 1)`**: ابتدا پردازه بررسی می‌کند که آیا مقدار `lock` برابر با ۰ است (قفل آزاد است). اگر بله، آن را به ۱ تغییر می‌دهد (قفل را می‌گیرد).
    
2. اگر مقدار `lock` برابر با ۰ نباشد، پردازه وارد **منتظر بودن مشغول (busy waiting)** می‌شود و تا زمان آزاد شدن قفل منتظر می‌ماند.
    
3. پس از اتمام بخش بحرانی، قفل آزاد می‌شود (`lock = 0`).
    

---

## ⚠️ آیا این راه‌حل مسئله بخش بحرانی را حل می‌کند؟

### ❓ مشکلات و نکات:

1. **منتظر بودن مشغول (Busy Waiting)**:
    
    - همانند دستور **test_and_set**، این روش نیز از **منتظر بودن مشغول** استفاده می‌کند که ممکن است باعث **اتلاف منابع** شود.
        
2. **Starvation (گرسنگی پردازه‌ها)**:
    
    - در صورتی که پردازه‌ها به‌طور مداوم نتوانند قفل را بدست آورند، ممکن است برخی از پردازه‌ها **هیچ‌گاه** وارد بخش بحرانی نشوند (گرسنگی).
        
3. **مقیاس‌پذیری**:
    
    - این روش ممکن است در سیستم‌های **چندپردازه‌ای (Multiprocessor)** مشکلاتی ایجاد کند، زیرا تمامی پردازه‌ها از همین قفل برای دسترسی به بخش بحرانی استفاده می‌کنند.
        

---

## 📋 نتیجه‌گیری

دستور **compare_and_swap** یک روش اتمیک است که برای حل مسئله **دسترسی همزمان به بخش بحرانی** استفاده می‌شود. این دستور می‌تواند به حل بسیاری از مشکلات مربوط به دسترسی به منابع مشترک کمک کند، اما همچنان به دلیل **منتظر بودن مشغول** و **گرسنگی پردازه‌ها** ممکن است در شرایط خاص کارایی سیستم را تحت تأثیر قرار دهد.

---
